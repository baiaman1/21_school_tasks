# Чистая архитектура и описание программного продукта

## Contents

[[_TOC_]]


## Chapter I

### Чистая архитектура. Что это такое?

Прежде, чем мы перейдём к чистой архитектуре, сначала познакомимся с так называемой "Гексогональной архитектурой".

### Гексогональная архитектура

Гексагональная архитектура — Hexagonal Architecture — также известна как архитектура портов и адаптеров. Её разработал Алистер Кокбёрн, а описали Стив Фриман и Нат Прайс в книге Growing Object Oriented Software with Tests.
Представляя собой один из вариантов слоёной архитектуры, гексагональная архитектура подразумевает разделение приложения на отдельные концептуальные слои, имеющие разные зоны ответственности. Архитектура также регламентирует то, каким образом слои связаны друг с другом. 

Гексагональная архитектура позволяет взаимодействовать с приложением как пользователю, так и программам, автоматическим тестам, скриптам пакетной обработки. Архитектура применяется в разработке и тестировании приложений без каких-либо дополнительных устройств или баз данных.

В гексагональной архитектуре предлагается инфраструктуру рассматривать как часть внешнего мира, и тогда система получается устроенной очень просто. Самый нижний уровень --- уровень предметной области. Над ним --- слои, обеспечивающие взаимодействие с внешним миром, которые включают в себя предоставляемые и потребляемые интерфейсы, и адаптеры, преобразующие данные из внешнего мира в чистую предметно-ориентированную модель:

![](./misc/images/hexagonal02.jpg)

### Луковая архитектура

Луковая архитектура (Onion architecture) - архитектура с довольно странным названием, являющаяся, на самом деле, уточнением гексагональной архитектуры. Идея такая же - есть модель предметной области, включающая в себя всю бизнес-логику и модель данных приложения (не только приложения, а целой системы - ведь ядро может переиспользоваться в нескольких приложениях сразу). Есть внешний мир, который с ядром взаимодействует. Однако она предписывает наличие в ядре дополнительных уровней:

![](./misc/images/onion.png)

Общее правило структурирования уровней тут следующее: внутренние слои ничего не знают о внешних, а лишь предоставляют интерфейсы и принимают в конструкторы зависимости по этим интерфейсам. В самом центре находится доменная модель (та самая модель предметной области) - классы, реализующие бизнес-логику и моделирующие сущности из реального мира. Над ней - доменные сервисы, то есть классы, использующие несколько сущностей в своей работе (функциональность, которую нельзя естественным образом отнести к одному из классов предметной области). Часто сервисы - это статические классы. Над слоем доменных сервисов - сервисы приложений, они занимаются оркестрацией объектов и сервисов предметной области, реализуют случаи использования, всячески поддерживают код, который пользуется компонентом из внешнего мира. Над слоем сервисов приложений находится уже внешний по отношению к компоненту мир - пользовательский интерфейс и механизмы доставки, инфраструктура, хранение данных и т.д. Уровневость нестрогая, то есть уровень вправе обращаться к объектам любого из уровней ниже.

Кстати, структура уровней в <<луковой архитектуре>> примерно соответствует уровням, предлагаемым в Domain-Driven Design. Единственное, что DDD разделяет инфраструктурный уровень и уровень приложения, тогда как тут они смешаны в один, поскольку и то и другое - штуки для поддержки внешних зависимостей компонента.


### Чистая архитектура
Чистая архитектура (Clean architecture) - дальнейшее уточнение идей луковой и гексагональной архитектур. Тоже предполагается слоистый стиль, где самый нижний слой - доменная модель, тоже зависимости направлены строго от внешних слоёв к внутренним, тоже используется Dependency Injection, чтобы классы доменной модели могли работать с внешним миром. Но в дополнение ко всему этому она специфицирует поток управления и определяет конкретные способы взаимодействия с пользователем.

Clean Architecture делит логическую структуру приложения на различные уровни обязанностей. Это упрощает изолирование зависимости (например, ваша база данных) и тестирование взаимодействия на границах между уровнями

Понятие «чистая архитектура» пошло из одноименной статьи Роберта Мартина 2012 года. Кратко повторим основные принципы:
Независимость от фреймворков. Архитектура не должна полагаться на существование какой-либо библиотеки. Так вы сможете использовать фреймворки как инструменты, а не пытаться загнать свою систему в их ограничения.
Тестируемость. Бизнес-логика должна быть тестируемой без любых внешних элементов вроде интерфейса, базы данных, сервера или любого другого элемента.
Независимость от интерфейса. Интерфейс должен легко изменяться и не требовать изменения остальной системы. Например, веб-интерфейс должен заменяться на интерфейс консоли без необходимости изменения бизнес-логики.
Независимость от базы данных. Ваша бизнес-логика не должна быть привязана и к конкретным базам данных.
Независимость от любого внешнего агента. Ваша бизнес-логика не должна знать вообще ничего о внешнем мире.

![](./misc/images/Clean-Architecture-Bob.png)

В этой схеме слои обозначают:
* Entities — бизнес-логика, общая для всех приложений, а в случае отдельного приложения — наиболее базовые бизнес-объекты.
* Use Cases — логика приложения, “сценарии применения”, которые управляют потоком данных из предыдущего слоя.
* Interface Adapters — адаптеры между Use Cases и внешним миром. Этот слой конвертирует данные в формат, подходящий для внешних слоев, например Web или базы данных, а также превращает внешние данные в формат для внутренних слоев.
* Frameworks and Drivers — внешний слой, содержащий фреймворки, инструменты, базы данных и так далее. В этом слое код должен связываться с предыдущим слоем, но не влиять в значительной степени на внутренние слои.
  
Все слои связаны правилом зависимости — Dependency Rule, которое гласит, что в исходном коде все зависимости могут указывать только вовнутрь. Например, ничто из внешнего круга не может быть упомянуто кодом из внутреннего круга. Это относится к функциям, классам, переменным или любым другим сущностям. Сам Uncle Bob говорит, что эту схему можно изменять: добавлять или убирать слои, но основным правилом в архитектуре приложения должно всегда оставаться Dependency Rule 

![](./misc/images/clean_code1.png)


### Паттерны проектирования

**Паттерны** — это способ построения (структуризации) программного кода специальным образом. На практике они используются для того, чтобы решить какую-нибудь проблему.

Паттерны бывают:

* GangOfFour - паттерны проектирования на уровне классов
* Архитектурные (MVC, MVVM, MVP, N-tier, SOA, микросервисная архитектура, Event-Driven архитектура) 
* DDD-паттерны, относящиеся к более низкому уровню как и GoF, Entity, Repository, UseCase/Sevice, Domain и т.д.
* Паттерны параллельного программирования: тред пул, распределенная транзакция, промисы и т.д.

Паттернами проектирования (Design Patterns) называют решения часто встречающихся проблем в области разработки программного обеспечения. В данном случае предполагается, что есть некоторый набор общих формализованных проблем, которые довольно часто встречаются, и паттерны предоставляют ряд принципов для решения этих проблем.

Группы паттернов:

* Порождающие.
* Структурные.
* Поведенческие.

Для чего нужны паттерны?

1. Использование проверенных решений позволяет тратить меньше времени и пользоваться готовыми решениями.

2. Меньше просчётов при проектировании, используя типовые решения, так как все скрытые проблемы в них уже найдены.

3. Общий программистский словарь. Мы произносим название паттерна, вместо того, чтобы длительное время объяснять другим программистам, что придумали, и какие классы для этого нужны.

### Сервис-ориентированная архитектура и микросервисная архитектура

#### SOA

SOA (**S**ervice-**O**riented **A**rchitecture) - метод разработки программного обеспечения, использующий программные компоненты (называемые сервисами) для создания бизнес-приложений. 

Каждый сервис предоставляет бизнес-возможности, причем сервисы могут взаимодействовать друг с другом будучи написанными на разных платформах и языках. Когда это используется? Для многократного использования сервисов в различных системах или для объединения независимых сервисов для выполнения сложных задач.

Например, многие приложения (даже внутри одной компании) требуют аутентификацию пользователя. Вместо того чтобы переписывать код аутентификации для всех бизнес-процессов, ты можешь создать единый сервис аутентификации и использовать его повторно для всех приложений.

Давай посмотрим на основные **преимущества** сервис-ориентированной архитектуры.

1) *Сокращение времени выхода на рынок*. В случае когда уже имеются готовые сервисы, которые можно переиспользовать, время разработки системы может серьезно сократиться.

2) *Эффективное обслуживание*. При развитой инфраструктуре обслуживать распределенную систему может быть проще в некоторых аспектах. Можно, например, обновлять сервисы по отдельности, не отключая всю систему целиком. А также сервисы можно хостить на разных машинах, что также даёт определенные преимущества

3) *Модульность*. Благодаря разбиению системы на сервисы, становится легко модифицировать её части.

![soa](images/Software_architecture_Project_4_0.jpg)


#### Микросервисная архитектура
Микросервисная архитектура (MSA - **M**icro **S**ervice **A**rchitecture) - развитие SOA. Микросервисы устраняют недостатки SOA (например, ограничение возможности масштабирования из-за возможного совместного использования ресурсов) и делают ПО более совместимым с облачными корпоративными средами.

Для развертывания приложений на основе MSA часто используют контейнерные технологии, такие как Docker и Kubernetes.

В микросервисной архитектуре приложение разбивается на ряд независимо развертываемых сервисов, которые взаимодействуют с помощью API-интерфейсов. Благодаря такому подходу каждый отдельный сервис можно развертывать и масштабировать независимо от других. В результате команды могут быстрее и чаще поставлять объемные и сложные приложения. В отличие от монолитного приложения, с микросервисной архитектурой команды могут быстрее внедрять новые возможности и вносить изменения, при этом им не приходится переписывать большие фрагменты существующего кода.

Пример микросервисной архитектуры (Web API магазина) представлен на картинке снизу.

![msa](images/Software_architecture_Project_4_1.svg)

### SDD (Software design description)

SDD - это описание программного продукта, который описывает, как правило, программный архитектор, чтобы дать понимание команде разработки всеобъемлющую информацию о разрабатываемом продукте.

SDD обычно сопровождается диаграммой архитектуры с указателями на подробные спецификации функций более мелких частей диаграммы. На практике описание требуется для координации работы большой команды в рамках единого видения, должно быть стабильным справочником и описывать все части программного обеспечения и то, как они будут взаимодействия.

Документация по разработке программного обеспечения - важный способ вовлечь в процесс всех, кто участвует в разработке продукта. Каждый должен понять, что возможно, а что нет, и какую систему необходимо спроектировать. 
Проектная документация создается для координации усилий большой команды, описывает все части программного обеспечения и то, как они будут взаимодействовать. Благодаря документации, инженеры, работающие над различным программным обеспечением, смогут гарантировать, что продукт построен в соответствии с потребностями и соответствует тому, что было согласовано до создания продукта. 
Документы по разработке программного обеспечения не только помогают понять си стему и предоставляют документацию для будущих проектов, но и заставляют заранее продумать всю архитектуру системы. 

[Технический проект. ГОСТ 2.120-2013](https://internet-law.ru/gosts/gost/58827/)

[Эскизный проект. ГОСТ 2.119-2013](https://internet-law.ru/gosts/gost/58832/)

Ниже приведены пункты, которые содержит типичный документ по разработке программного обеспечения: 
1. Заглавие - Название документа. 
2. Вступление 
Обзор всего документа и его цели. 
3. Обзор проекта 
Общее описание и функциональные возможности программного обеспечения. 
4. Конструктивные соображения 
Стоит перечислить препятствия, которые необходимо устранить перед созданием программного обеспечения. 
Они будут включать такие детали, как: 
    • Любые возможные неправильные предположения или какие-либо зависимости; 
    • Общие ограничения, которые могут повлиять на разработку программного обеспечения; 
    • Цели и рекомендации по разработке программного обеспечения; 
    • Методологию разработки, которая будет использоваться. 
5. Архитектурные стратегии 
Стратегии, которые будут использоваться, повлияют на систему. 
6. Архитектура системы 
Обзор на высоком уровне того, как функциональные возможности и обязанности системы были разделены и распределены по подсистемам или компонентам. 
7. Политика и тактика 
Политика и тактика проектирования, которые не имеют широких архитектурных последствий. То есть они не окажут существенного влияния на общую организацию системы и ее структуры. 
8. Детальный дизайн системы 
Большинство компонентов, описанных в разделе Архитектура системы(п.6), потребуют более подробного обсуждения. Возможно, потребуется также описать другие компоненты и подкомпоненты более низкого уровня. 
9. Роли и обязанности 
Информация об участниках, включая владельца продукта, членов команды и за интересованных лиц, с четко определенными обязанностями и запланированными целями выпуска для каждого из членов команды. 
10. Допущения 
Список технических или деловых предположений, которые могут быть у команды. 
11. Принципы архитектуры и дизайна 
Описывает руководящую архитектуру и принципы проектирования, с помощью которых будет разрабатываться продукт. 
12. Схематическое представление программного обеспечения/продукта 
Диаграммы, которые помогут понять и донести структуру и принципы проектирования. 
13. Документ с исходным кодом (необязательно) 
Документ с исходным кодом - это технический раздел, в котором объясняется, как работает код. 
Документы исходного кода могут включать такие детали, как: 
    • Фреймворк генерации HTML и другие применяемые фреймворки;
    • Тип привязки данных; 
    • Шаблон дизайна с примерами; 
    • Меры безопасности; 
    • Другие модели и принципы. 
14. Гарантия качества 
Наиболее распространенными являются: 
    • Стратегия тестирования; 
    • План тестирования; 
    • Технические характеристики тестового случая; 
    • Контрольные списки тестов. 
15. Глоссарий 
Полный список определенных терминов и понятий, используемых во всем документе

### UML

Unified Modeling Language — унифицированный язык моделирования — язык графического описания для объектного моделирования в области разработки программного обеспечения, для моделирования бизнес-процессов 1, системного проектирования и отображения организационных структур.

UML является языком широкого профиля, это — открытый стандарт, использующий графические обозначения для создания абстрактной модели системы, называемой UML-моделью. UML был создан для определения, визуализации, проектирования и документирования, в основном, программных систем. UML не является языком программирования, но на основании UML-моделей возможна генерация кода.

Проще говоря, UML, от слова Unified - это язык, который понимаем не только мы, но и все, кто знаком с UML. 

### IDEF
Диаграммы случаев использования хороши тем, что они очень просты и ни к чему не обязывают (из всего UML можно использовать только их, и они легко вписываются в любую методологию), так что применяются даже в Agile-командах иногда. Но есть ещё более простая нотация (и гораздо более древняя): контекстные диаграммы языка IDEF0.

Вообще языки семейства IDEF (Integration DEFinition, в оригинале --- ICAM DEFinition) разрабатывались аж в 1970-х годах по заказу минобороны США, когда у тех возникла потребность в разработке сложного mission-critical программного обеспечения и подхода ``фигачить код'' стало не хватать. Семейство на данный момент включает в себя 14 языков (как UML), но широкую известность получили только IDEF0 и IDEF1x, так что упоминаются в этом курсе только они.

### ArchiMate
ArchiMate - это открытый и независимый язык моделирования архитектуры предприятия для поддержки описания, анализа и визуализации архитектуры внутри и за пределами бизнес-процессов однозначным способом.

ArchiMate — это технический стандарт от The Open Group, базирующийся на IEEE 1471. Он поддерживается различными разработчиками инструментов моделирования и консалтинговыми организациями. ArchiMate, также является зарегистрированным товарным знаком, принадлежащим The Open Group. The Open Group разработало сертификационную программу для программных инструментов, пользователей и курсов по ArchiMate.

### C4 (Не бомба)
Модель C4 была создана как способ помочь командам разработчиков программного обеспечения описать и передать архитектуру программного обеспечения, как во время предварительных сессий проектирования, так и при ретроспективном документировании существующей кодовой базы. Это способ создания схем вашего кода с различными уровнями детализации, точно так же, как вы использовали бы что-то вроде Google Maps для увеличения и уменьшения масштаба интересующей вас области.

Хотя модель C4 в первую очередь предназначена для архитекторов и разработчиков программного обеспечения, она предоставляет командам разработчиков программного обеспечения возможность эффективно и действенно описывать свою архитектуру программного обеспечения на разных уровнях детализации, показывая различного уровня модели при диалоге с разными типам аудитории при выполнении предварительного проектирования или ретроспективном документировании существующей кодовой базы.

![](./misc//images/C4.png)

Модель C4 - это подход "сначала абстракция" к построению диаграмм архитектуры программного обеспечения, основанный на абстракциях, которые отражают то, как архитекторы и разработчики программного обеспечения представляют и строят программное обеспечение. Небольшой набор абстракций и типов диаграмм делает модель C4 простой в освоении и использовании. Пожалуйста, обратите внимание, что вам не нужно использовать все 4 уровня диаграммы; только те, которые повышают ценность - системный контекст и диаграммы контейнеров достаточны для многих групп разработчиков программного обеспечения.


## Chapter III

Итогом выполненной работы должен быть документ с описанием SDD. Допускается использование форматов MD или PDF. Документ формируется в виде файла в директории src с именем SDD и соответствующим расширением.

### Part1. Написание SDD проекта

Итак, вы теперь в команде. В качестве основы для данного проекта необходимо выбрать проект, выполненный одним из участников команды. Вам необходимо спроектировать SDD с описанием архитектуры системы


**== Задание ==**

1. Заглавие - Название документа. 
2. Вступление  
3. Обзор проекта 

   3.1. Описать все возможные функциональности системы

   3.2. Система должна состоять минимум из 5 микросервисов

   3.3. Документ должен описывать стратегию тестирования, развёртывания и сборки

   3.4. Система должна имплементировать ролевую аутентификацию.

4. Конструктивные соображения 

5. Архитектурные стратегии  

6. Архитектура системы 

    6.1. Описание архитектуры системы основывается на подходе CleanCode

    6.2. Описание архитектуры содержит:
        * IDEF 0 описание системы (минимум 3 уровня вложенности)
        * UML Диаграмма последовательности действий
        * UML Диаграмма состояний
        * UML use-case
        * UML Диаграмма деятельности
        * Диаграммы должны быть чистыми, читабельными и прозрачными

7. Политика и тактика  

8. Детальный дизайн системы 

    8.1. Описать детальный дизайн системы
        * IDEF 0 
        * UML Диаграмма последовательности действий
        * UML Диаграмма состояний
        * UML Диаграмма деятельности

9.  Роли и обязанности 

10. Допущения 

11. Принципы архитектуры и дизайна  

12. Схематическое представление программного обеспечения/продукта  

13. Гарантия качества 

14. Глоссарий 

**Важно!** При проектировании системы и составлении SDD использовать подход **чистой архитектуры**.
